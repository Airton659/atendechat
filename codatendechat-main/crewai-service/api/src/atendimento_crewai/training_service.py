# api/src/atendimento_crewai/training_service.py - Servi√ßo de Treinamento Interativo

from fastapi import APIRouter, HTTPException, Body
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import json
import time
from datetime import datetime

from firebase_admin import firestore

router = APIRouter(prefix="/training", tags=["Training"])

class GenerateResponseRequest(BaseModel):
    tenantId: str
    teamId: str
    agentId: Optional[str] = None
    message: str
    conversationHistory: List[Dict[str, Any]] = []

class ToggleValidationRequest(BaseModel):
    teamId: str
    tenantId: str
    agentId: str
    enabled: bool

class TrainingService:
    def __init__(self):
        self.db = firestore.client()

    async def get_team_blueprint(self, tenant_id: str, team_id: str) -> Dict[str, Any]:
        """Obt√©m o blueprint da equipe"""
        try:
            # Tentar primeiro em 'crews' (nova estrutura)
            team_doc = self.db.collection('crews').document(team_id).get()

            # Se n√£o encontrar, tentar em 'crews' (estrutura antiga)
            if not team_doc.exists:
                team_doc = self.db.collection('crews').document(team_id).get()

            if not team_doc.exists:
                raise Exception(f"Equipe {team_id} n√£o encontrada")

            team_data = team_doc.to_dict()

            # Verifica√ß√£o de tenant - comentada pois pode n√£o existir em todas as equipes
            # if team_data.get('tenantId') != tenant_id:
            #     raise Exception("Acesso negado √† equipe")

            return team_data
        except Exception as e:
            raise Exception(f"Erro ao obter equipe: {str(e)}")

    async def get_knowledge_context(self, crew_id: str, query: str, max_results: int = 3, document_ids: List[str] = None) -> List[Dict[str, Any]]:
        """Busca contexto relevante na base de conhecimento usando busca por palavra-chave"""
        try:
            results = []

            # Busca por palavra-chave nos vetores usando crewId (n√£o tenantId!)
            vectors_ref = self.db.collection('vectors').where('crewId', '==', crew_id)

            query_lower = query.lower()
            query_words = set(query_lower.split())

            print(f"üîç Buscando por palavra-chave: '{query}' (crew: {crew_id})")
            if document_ids:
                print(f"   Filtrando por {len(document_ids)} documento(s) espec√≠fico(s): {document_ids}")

            all_chunks = list(vectors_ref.stream())
            total_chunks = len(all_chunks)
            print(f"   üìä Total de chunks encontrados na crew: {total_chunks}")

            chunks_after_filter = []
            chunks_with_score = []

            for doc in all_chunks:
                data = doc.to_dict()

                # Filtrar por documentos espec√≠ficos se fornecido
                if document_ids and data.get('documentId') not in document_ids:
                    continue

                chunks_after_filter.append(data)
                content = data.get('content', '').lower()

                # Calcular score baseado em palavras encontradas
                score = 0
                for word in query_words:
                    if word in content:
                        score += content.count(word)

                if score > 0:
                    chunks_with_score.append(data)
                    results.append({
                        'content': data.get('content'),
                        'metadata': data.get('metadata', {}),
                        'similarity': score,
                        'documentId': data.get('documentId'),
                        'chunkIndex': data.get('chunkIndex', 0)
                    })

            print(f"   üìä Chunks ap√≥s filtrar por documentId: {len(chunks_after_filter)}")
            print(f"   üìä Chunks com score > 0: {len(chunks_with_score)}")

            # Ordenar por score
            results.sort(key=lambda x: x['similarity'], reverse=True)

            print(f"‚úÖ Encontrados {len(results)} resultados por palavra-chave")

            return results[:max_results]

        except Exception as e:
            print(f"Erro ao buscar contexto: {e}")
            import traceback
            traceback.print_exc()
            return []

    async def generate_training_response(self, request: GenerateResponseRequest) -> Dict[str, Any]:
        """Gera resposta usando a equipe de IA para treinamento"""
        try:
            start_time = time.time()

            # Obter blueprint da equipe
            team_data = await self.get_team_blueprint(request.tenantId, request.teamId)

            # DEBUG: Log do agente solicitado
            print(f"\nüìã REQUEST DEBUG:")
            print(f"   agentId solicitado: '{request.agentId}'")
            print(f"   agentId type: {type(request.agentId)}")
            print(f"   agentId bool: {bool(request.agentId)}")
            print(f"   Agentes dispon√≠veis: {list(team_data.get('agents', {}).keys())}")

            # Determinar qual agente usar
            agent_to_use = self._select_agent_for_training(team_data, request.agentId, request.message)
            print(f"   ‚úÖ Agente selecionado: '{agent_to_use}'\n")

            # Construir prompt para o agente
            agent_config = team_data['agents'][agent_to_use]

            # Obter documentos espec√≠ficos do agente
            agent_document_ids = agent_config.get('knowledgeDocuments', [])

            # Buscar contexto na base de conhecimento (filtrado por documentos do agente)
            knowledge_context = await self.get_knowledge_context(
                request.teamId,  # Usar teamId/crewId, N√ÉO tenantId!
                request.message,
                document_ids=agent_document_ids if agent_document_ids else None
            )

            # DEBUG: Log da configura√ß√£o do agente
            print(f"\nüé≠ DEBUG - Configura√ß√£o do agente '{agent_to_use}':")
            print(f"   Nome: {agent_config.get('name')}")
            print(f"   Training: {agent_config.get('training')}")
            print(f"   Knowledge Docs: {agent_config.get('knowledgeDocuments')}")
            print(f"   Tools: {agent_config.get('tools')}\n")

            # EXECUTAR FERRAMENTAS SE NECESS√ÅRIO
            tools_context = ""
            agent_tools = agent_config.get('tools', [])
            tool_configs = agent_config.get('toolConfigs', {})
            message_lower = request.message.lower()

            # 0. FERRAMENTA DE BUSCAR CLIENTE (executar primeiro se houver n√∫mero de telefone)
            if 'buscar_cliente_planilha' in agent_tools and 'buscarCliente' in tool_configs:
                print(f"\nüîç Agente tem ferramenta de busca de cliente configurada")

                # Tentar extrair telefone da mensagem
                import re
                telefone_match = re.search(r'(\d{10,11})', request.message)

                if telefone_match:
                    telefone_busca = telefone_match.group(1)
                    buscar_config = tool_configs['buscarCliente']
                    spreadsheet_id = buscar_config.get('spreadsheetId', '')
                    range_name = buscar_config.get('rangeName', 'Clientes!A:F')

                    if spreadsheet_id:
                        print(f"   üîé Buscando cliente com telefone: {telefone_busca}")

                        try:
                            from .tools import _buscar_cliente_planilha_impl

                            busca_result = _buscar_cliente_planilha_impl(
                                spreadsheet_id=spreadsheet_id,
                                range_name=range_name,
                                telefone=telefone_busca,
                                tenant_id=request.tenantId
                            )

                            # Se encontrou o cliente, adicionar ao contexto
                            if "‚úÖ Cliente encontrado" in busca_result:
                                tools_context += f"\n\nINFORMA√á√ïES DO CLIENTE:\n{busca_result}\n"
                                print(f"   ‚úÖ Cliente encontrado e adicionado ao contexto")
                            else:
                                print(f"   ‚ÑπÔ∏è Cliente n√£o encontrado na base")

                        except Exception as e:
                            print(f"   ‚ö†Ô∏è Erro ao buscar cliente: {e}")

            # 1. FERRAMENTA DE CADASTRO EM GOOGLE SHEETS
            if 'cadastrar_cliente_planilha' in agent_tools:
                print(f"\nüìä Agente tem ferramenta de Google Sheets configurada")
                print(f"   Tool configs: {tool_configs}")

                # Palavras que indicam cadastro/registro (espec√≠ficas!)
                cadastro_keywords = [
                    'quero me cadastr', 'fazer cadastro', 'cadastr',
                    'me registr', 'fazer registro', 'registr',
                    'meu nome √©', 'me chamo'
                ]

                # Verificar se mensagem parece ser um cadastro
                is_cadastro = any(keyword in message_lower for keyword in cadastro_keywords)

                if is_cadastro and 'googleSheets' in tool_configs:
                    print(f"   üéØ Mensagem detectada como cadastro!")

                    sheets_config = tool_configs['googleSheets']
                    spreadsheet_id = sheets_config.get('spreadsheetId', '')
                    range_name = sheets_config.get('rangeName', 'Clientes!A:E')

                    if spreadsheet_id:
                        print(f"   Tentando cadastrar em planilha: {spreadsheet_id}")

                        try:
                            from .tools import _cadastrar_cliente_planilha_impl
                            import re
                            from datetime import datetime

                            # Extrair informa√ß√µes da mensagem usando regex
                            message_text = request.message.lower()

                            # Extrair nome (procurar por "nome √©/:" seguido de texto)
                            nome_match = re.search(r'(?:nome\s+(?:√©|e)\s+|me\s+chamo\s+|sou\s+o?\s*)([A-Za-z√Ä-√ø\s]+?)(?:\s*,|\s+meu|\s+telefone|\s+email|\s+e-mail|$)', request.message, re.IGNORECASE)
                            nome = nome_match.group(1).strip() if nome_match else ""

                            # Extrair telefone (procurar por n√∫meros com 10-11 d√≠gitos)
                            telefone_match = re.search(r'(?:telefone|fone|cel|celular|whats|whatsapp)?\s*:?\s*(\d{10,11})', request.message, re.IGNORECASE)
                            telefone = telefone_match.group(1) if telefone_match else ""

                            # Extrair email
                            email_match = re.search(r'(?:email|e-mail|mail)?\s*:?\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', request.message, re.IGNORECASE)
                            email = email_match.group(1) if email_match else ""

                            # Data/hora atual
                            data_cadastro = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                            # Se n√£o extraiu nome, usar mensagem completa
                            if not nome:
                                nome = request.message

                            print(f"   üìù Dados extra√≠dos:")
                            print(f"      Nome: {nome}")
                            print(f"      Telefone: {telefone}")
                            print(f"      Email: {email}")
                            print(f"      Data: {data_cadastro}")

                            tool_result = _cadastrar_cliente_planilha_impl(
                                spreadsheet_id=spreadsheet_id,
                                range_name=range_name,
                                nome=nome,
                                telefone=telefone,
                                email=email,
                                observacoes=f"Cadastrado via treinamento - {team_data.get('name', 'Equipe')} em {data_cadastro}",
                                tenant_id=request.tenantId
                            )

                            tools_context += f"\n\nRESULTADO DO CADASTRO:\n{tool_result}\n"
                            print(f"   ‚úÖ Cadastro executado com sucesso")

                        except Exception as e:
                            error_msg = f"Erro ao cadastrar: {str(e)}"
                            tools_context += f"\n\nERRO NO CADASTRO:\n{error_msg}\n"
                            print(f"   ‚ùå Erro ao executar cadastro: {e}")
                    else:
                        print(f"   ‚ö†Ô∏è spreadsheet_id n√£o configurado")

            # 2. FERRAMENTA DE AGENDAMENTO
            if 'coletar_info_agendamento' in agent_tools:
                print(f"\nüìÖ Agente tem ferramenta de agendamento configurada")

                # Palavras que indicam agendamento
                agendamento_keywords = [
                    'agendar', 'marcar', 'hor√°rio', 'hora', 'dia',
                    'consulta', 'reuni√£o', 'encontro', 'atendimento',
                    'dispon√≠vel', 'disponibilidade'
                ]

                is_agendamento = any(keyword in message_lower for keyword in agendamento_keywords)

                if is_agendamento:
                    print(f"   üéØ Mensagem detectada como agendamento!")

                    try:
                        from .tools import _coletar_info_agendamento_impl

                        # Coletar informa√ß√µes da mensagem
                        tool_result = _coletar_info_agendamento_impl(
                            nome_cliente="Cliente",  # TODO: Extrair do contexto
                            tipo_servico=request.message,
                            data_desejada="",    # TODO: Extrair da mensagem
                            horario_preferencia="", # TODO: Extrair da mensagem
                            telefone="",
                            observacoes=f"Solicitado via treinamento"
                        )

                        tools_context += f"\n\nINFORMA√á√ïES DE AGENDAMENTO COLETADAS:\n{tool_result}\n"
                        print(f"   ‚úÖ Informa√ß√µes de agendamento coletadas")

                    except Exception as e:
                        error_msg = f"Erro ao coletar agendamento: {str(e)}"
                        tools_context += f"\n\nERRO NO AGENDAMENTO:\n{error_msg}\n"
                        print(f"   ‚ùå Erro ao coletar agendamento: {e}")

            # PR√â-FILTRAR contexto do conhecimento baseado em guardrails
            # Obter guardrails do agente ANTES de processar conhecimento
            agent_training = agent_config.get('training', {})
            guardrails = agent_training.get('guardrails', {})
            dont_rules = guardrails.get('dont', [])

            # Palavras-chave proibidas extra√≠das das regras "don't"
            forbidden_keywords = []
            for rule in dont_rules:
                rule_lower = rule.lower()
                # Extrair palavras-chave importantes das regras
                if 'compra' in rule_lower or 'comprar' in rule_lower:
                    forbidden_keywords.extend(['compra', 'comprar', 'venda'])
                if 'vend' in rule_lower:
                    forbidden_keywords.extend(['venda', 'vender'])

            print(f"üîç Palavras-chave proibidas detectadas: {forbidden_keywords}")

            # Preparar contexto do conhecimento COM FILTRO
            context_text = ""
            if knowledge_context:
                filtered_context = []
                for ctx in knowledge_context:
                    content_lower = ctx['content'].lower()

                    # Verificar se o conte√∫do cont√©m palavras proibidas
                    is_forbidden = False
                    for keyword in forbidden_keywords:
                        if keyword in content_lower:
                            is_forbidden = True
                            print(f"   ‚õî Filtrado: cont√©m palavra proibida '{keyword}'")
                            break

                    if not is_forbidden:
                        filtered_context.append(ctx)

                print(f"üìä Contexto filtrado: {len(knowledge_context)} ‚Üí {len(filtered_context)} itens")

                if filtered_context:
                    context_text = "Contexto relevante da base de conhecimento:\n"
                    for i, ctx in enumerate(filtered_context, 1):
                        source = ctx.get('metadata', {}).get('source', 'documento')
                        context_text += f"{i}. [{source.upper()}] {ctx['content']}\n"
                    context_text += "\n"
                else:
                    print("‚ö†Ô∏è Todos os resultados foram filtrados por violar guardrails")


            # Construir hist√≥rico da conversa
            conversation_context = ""
            if request.conversationHistory:
                conversation_context = "Hist√≥rico da conversa:\n"
                for msg in request.conversationHistory[-5:]:  # √öltimas 5 mensagens
                    role = "Usu√°rio" if msg['role'] == 'user' else "Assistente"
                    conversation_context += f"{role}: {msg['content']}\n"
                conversation_context += "\n"

            # PILAR 2: Obter treinamento do agente (agent_training j√° foi obtido acima para filtro)
            persona = agent_training.get('persona', '').strip()
            do_rules = guardrails.get('do', [])

            # Construir se√ß√£o de guardrails
            guardrails_text = ""
            if do_rules or dont_rules:
                guardrails_text = "\n" + "="*50 + "\n"
                guardrails_text += "REGRAS CR√çTICAS (SIGA RIGOROSAMENTE):\n"
                guardrails_text += "="*50 + "\n"

                if do_rules:
                    guardrails_text += "\nüî¥ OBRIGAT√ìRIO - Voc√™ DEVE:\n"
                    for rule in do_rules:
                        if rule and rule.strip():
                            guardrails_text += f"  ‚Ä¢ {rule}\n"

                if dont_rules:
                    guardrails_text += "\nüö´ PROIBIDO - Voc√™ N√ÉO DEVE:\n"
                    for rule in dont_rules:
                        if rule and rule.strip():
                            guardrails_text += f"  ‚Ä¢ {rule}\n"

            # PILAR 2: Exemplos de Intera√ß√£o (Few-shot Learning)
            # Pegar exemplos espec√≠ficos do agente primeiro, depois exemplos gerais da equipe
            agent_examples = agent_training.get('examples', [])
            team_examples = team_data.get('blueprint', {}).get('training', {}).get('examples', [])

            # Combinar exemplos: prioridade para exemplos do agente
            all_examples = agent_examples + team_examples

            examples_text = ""
            if all_examples:
                examples_text = "\n" + "="*70 + "\n"
                examples_text += "üéØ EXEMPLOS DE RESPOSTAS CORRETAS - SIGA EXATAMENTE ESTE PADR√ÉO\n"
                examples_text += "="*70 + "\n"
                examples_text += "\n‚ö†Ô∏è  ATEN√á√ÉO: Voc√™ DEVE replicar o estilo, formato e abordagem destes exemplos.\n"
                examples_text += "Estas s√£o as √öNICAS respostas corretas e aprovadas para situa√ß√µes similares.\n\n"

                # Pegar os 5 exemplos mais recentes
                recent_examples = all_examples[-5:] if len(all_examples) > 5 else all_examples

                for i, example in enumerate(recent_examples, 1):
                    scenario = example.get('scenario', '')
                    good = example.get('good', '')
                    bad = example.get('bad', '')

                    if scenario and good:
                        examples_text += f"‚îÅ‚îÅ‚îÅ EXEMPLO {i} ‚îÅ‚îÅ‚îÅ\n"
                        examples_text += f"üìã SITUA√á√ÉO:\n{scenario}\n\n"
                        examples_text += f"‚úÖ RESPOSTA OBRIGAT√ìRIA (copie este padr√£o):\n"
                        examples_text += f"„Äå{good}„Äç\n"
                        examples_text += f"\n‚ö†Ô∏è  Para situa√ß√µes similares, voc√™ DEVE responder seguindo EXATAMENTE este modelo acima.\n"
                        examples_text += "‚îÄ"*70 + "\n\n"

                print(f"üìö {len(recent_examples)} exemplo(s) de treinamento carregado(s) ({len(agent_examples)} espec√≠ficos do agente, {len(team_examples)} gerais)")

            # Construir prompt espec√≠fico para treinamento
            training_prompt = f"""
            ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ATEN√á√ÉO CR√çTICA - LEIA ISTO PRIMEIRO ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
            {guardrails_text}

            ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            üö® ANTES DE RESPONDER, RELEIA AS REGRAS PROIBIDAS ACIMA üö®
            QUALQUER VIOLA√á√ÉO DESSAS REGRAS RESULTAR√Å EM RESPOSTA INCORRETA
            ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            Voc√™ est√° em uma sess√£o de TREINAMENTO INTERATIVO. O objetivo √© fornecer a melhor resposta poss√≠vel para que o usu√°rio possa avaliar e melhorar sua performance.

            PAPEL: {agent_config['role']}
            OBJETIVO: {agent_config['goal']}
            CONTEXTO: {agent_config.get('backstory', '')}

            {"PERSONA:\n" + persona if persona else ""}

            PERSONALIDADE:
            - Tom: {agent_config.get('personality', {}).get('tone', 'friendly')}
            - Caracter√≠sticas: {', '.join(agent_config.get('personality', {}).get('traits', []))}
            - Instru√ß√µes especiais: {agent_config.get('personality', {}).get('customInstructions', '')}

            {examples_text}
            {context_text}
            {tools_context}
            {conversation_context}

            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            üì© MENSAGEM DO USU√ÅRIO:
            {request.message}
            ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

            üéØ INSTRU√á√ïES CR√çTICAS - REVISE ANTES DE RESPONDER:

            ‚ö†Ô∏è  PRIORIDADE M√ÅXIMA #1 - GUARDRAILS:
               ‚Ä¢ RELEIA as regras PROIBIDAS no topo deste prompt
               ‚Ä¢ Se sua resposta violar QUALQUER regra proibida, PARE e reformule
               ‚Ä¢ NUNCA cite, mencione ou ofere√ßa algo que esteja nas regras PROIBIDAS
               ‚Ä¢ Mesmo que a base de conhecimento contenha, IGNORE se for proibido

            ‚ö†Ô∏è  PRIORIDADE M√ÅXIMA #2 - FILTRO DE CONHECIMENTO:
               ‚Ä¢ A base de conhecimento acima pode conter informa√ß√µes PROIBIDAS
               ‚Ä¢ Voc√™ DEVE FILTRAR e mostrar APENAS o que est√° permitido pelas regras
               ‚Ä¢ Exemplo: Se a base tem 10 im√≥veis mas 5 s√£o para COMPRA (proibido), mostre APENAS os 5 permitidos
               ‚Ä¢ NUNCA mencione que existem op√ß√µes filtradas ou proibidas
               ‚Ä¢ Se TODOS os resultados forem proibidos, informe que n√£o h√° op√ß√µes dispon√≠veis no momento
               ‚Ä¢ Seja PRECISO: se o cliente pede "casa em Curitiba", mostre apenas casas em Curitiba (n√£o Londrina, n√£o S√£o Paulo)

            ‚ö†Ô∏è  PRIORIDADE M√ÅXIMA #3 - EXEMPLOS:
               ‚Ä¢ Se h√° EXEMPLOS DE RESPOSTAS CORRETAS acima, voc√™ DEVE:
               ‚Ä¢ Replicar EXATAMENTE o estilo, tom e formato mostrado nos exemplos
               ‚Ä¢ Usar a mesma estrutura de resposta dos exemplos
               ‚Ä¢ Os exemplos s√£o OBRIGAT√ìRIOS - n√£o s√£o opcionais

            üìã CHECKLIST ANTES DE RESPONDER:
            1. ‚úÖ Minha resposta viola alguma regra PROIBIDA? Se SIM, reformule!
            2. ‚úÖ Filtrei TODOS os itens proibidos da base de conhecimento?
            3. ‚úÖ Minha resposta √© PRECISA (cidade, tipo, caracter√≠sticas corretas)?
            4. ‚úÖ Estou seguindo os exemplos fornecidos?
            5. ‚úÖ Estou mantendo o tom e personalidade definidos?

            ‚ö†Ô∏è  LEMBRE-SE: Se voc√™ mencionar algo PROIBIDO ou impreciso, sua resposta ser√° REPROVADA.

            RESPOSTA:
            """

            # Log do prompt completo para debug
            print("\n" + "="*80)
            print("PROMPT DE TREINAMENTO ENVIADO AO MODELO:")
            print("="*80)
            print(training_prompt)
            print("="*80 + "\n")

            # Gerar resposta usando Vertex AI com retry para 429
            from vertexai.generative_models import GenerativeModel, GenerationConfig
            import os

            model_name = os.getenv("VERTEX_MODEL", "gemini-2.5-flash-lite")
            model = GenerativeModel(model_name)

            # Configura√ß√£o de gera√ß√£o: temperatura baixa para respostas mais precisas e determin√≠sticas
            generation_config = GenerationConfig(
                temperature=0.2,  # Baixa temperatura = mais focado, menos criativo, mais determin√≠stico
                top_p=0.8,       # Amostragem nucleus: considera tokens com probabilidade acumulada de 80%
                top_k=40,        # Considera os 40 tokens mais prov√°veis
                max_output_tokens=2048
            )

            # Tentar at√© 3 vezes com backoff exponencial em caso de erro 429
            max_retries = 3
            retry_delay = 2  # segundos
            last_error = None

            for attempt in range(max_retries):
                try:
                    response = model.generate_content(
                        training_prompt,
                        generation_config=generation_config
                    )
                    ai_response = response.text.strip()
                    break  # Sucesso, sair do loop
                except Exception as e:
                    error_msg = str(e)
                    last_error = e

                    # Se for erro 429 (rate limit), tentar novamente
                    if "429" in error_msg or "Resource exhausted" in error_msg or "quota" in error_msg.lower():
                        if attempt < max_retries - 1:  # N√£o √© a √∫ltima tentativa
                            wait_time = retry_delay * (2 ** attempt)  # Backoff exponencial: 2s, 4s, 8s
                            print(f"‚ö†Ô∏è Erro 429 (Rate Limit) - Aguardando {wait_time}s antes de tentar novamente (tentativa {attempt + 1}/{max_retries})")
                            time.sleep(wait_time)
                            continue
                        else:
                            print(f"‚ùå Erro 429 persistiu ap√≥s {max_retries} tentativas")
                            raise HTTPException(
                                status_code=429,
                                detail="Limite de requisi√ß√µes atingido. Por favor, aguarde alguns segundos e tente novamente."
                            )
                    else:
                        # Outro tipo de erro, n√£o tentar novamente
                        raise e
            else:
                # Se chegou aqui, todas as tentativas falharam
                raise last_error if last_error else Exception("Falha ao gerar resposta")

            # Calcular tempo de resposta
            response_time = time.time() - start_time

            # Calcular score de confian√ßa baseado na presen√ßa de contexto
            confidence_score = 0.8  # Base
            if knowledge_context:
                confidence_score += 0.1  # Boost por ter contexto
            if len(ai_response) > 50:
                confidence_score += 0.1  # Boost por resposta substantiva

            confidence_score = min(confidence_score, 1.0)

            return {
                "response": ai_response,
                "agentUsed": agent_to_use,
                "responseTime": round(response_time, 2),
                "confidenceScore": confidence_score,
                "knowledgeUsed": len(knowledge_context),
                "metadata": {
                    "agentConfig": {
                        "name": agent_config['name'],
                        "role": agent_config['role'],
                        "tone": agent_config.get('personality', {}).get('tone', 'friendly')
                    },
                    "contextSources": [ctx.get('metadata', {}).get('source', 'unknown') for ctx in knowledge_context]
                }
            }

        except Exception as e:
            print(f"Erro na gera√ß√£o de resposta para treinamento: {e}")
            raise Exception(f"Erro ao gerar resposta: {str(e)}")

    def _select_agent_for_training(self, team_data: Dict[str, Any], requested_agent: str = None, message: str = "") -> str:
        """Seleciona qual agente usar para o treinamento"""

        agents = team_data.get('agents', {})

        # Se agente espec√≠fico foi solicitado, usar ele
        if requested_agent and requested_agent in agents:
            return requested_agent

        # Usar agente de entrada padr√£o se definido
        workflow = team_data.get('workflow', {})
        entry_point = workflow.get('entryPoint')

        if entry_point and entry_point in agents:
            return entry_point

        # Buscar agente de triagem
        for agent_key in agents.keys():
            if 'triagem' in agent_key.lower():
                return agent_key

        # Usar primeiro agente ativo
        for agent_key, agent_config in agents.items():
            if agent_config.get('isActive', True):
                return agent_key

        # Fallback: primeiro agente dispon√≠vel
        return list(agents.keys())[0] if agents else 'geral'

    async def analyze_training_conversation(self, conversation: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analisa uma conversa de treinamento para insights"""
        try:
            analysis = {
                "totalMessages": len(conversation),
                "userMessages": 0,
                "aiMessages": 0,
                "corrections": 0,
                "avgMessageLength": 0,
                "topics": [],
                "sentiment": "neutral",
                "improvementAreas": []
            }

            total_length = 0
            user_messages = []
            ai_messages = []
            corrections = []

            for msg in conversation:
                total_length += len(msg.get('content', ''))

                if msg.get('role') == 'user':
                    analysis["userMessages"] += 1
                    if msg.get('type') != 'user_correction':
                        user_messages.append(msg['content'])
                elif msg.get('role') == 'assistant':
                    analysis["aiMessages"] += 1
                    ai_messages.append(msg['content'])
                elif msg.get('role') == 'correction':
                    analysis["corrections"] += 1
                    corrections.append(msg['content'])

            if len(conversation) > 0:
                analysis["avgMessageLength"] = total_length / len(conversation)

            # An√°lise de t√≥picos simples (palavras-chave frequentes)
            all_text = " ".join(user_messages + ai_messages).lower()
            words = all_text.split()
            word_freq = {}

            for word in words:
                if len(word) > 3:  # Ignorar palavras muito curtas
                    word_freq[word] = word_freq.get(word, 0) + 1

            # Top 5 palavras mais frequentes como t√≥picos
            sorted_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
            analysis["topics"] = [word for word, freq in sorted_words[:5] if freq > 1]

            # √Åreas de melhoria baseadas em corre√ß√µes
            if analysis["corrections"] > 0:
                correction_ratio = analysis["corrections"] / max(analysis["aiMessages"], 1)
                if correction_ratio > 0.3:
                    analysis["improvementAreas"].append("Alta taxa de corre√ß√µes - revisar treinamento")
                if analysis["avgMessageLength"] < 50:
                    analysis["improvementAreas"].append("Respostas muito curtas - incentivar mais detalhamento")

            return analysis

        except Exception as e:
            print(f"Erro na an√°lise da conversa: {e}")
            return {"error": str(e)}

# Inst√¢ncia global do servi√ßo
training_service = TrainingService()

@router.post("/generate-response")
async def generate_response(request: GenerateResponseRequest = Body(...)):
    """
    Gera resposta da IA para sess√£o de treinamento
    """
    try:
        if not request.message or len(request.message.strip()) < 1:
            raise HTTPException(status_code=400, detail="Mensagem √© obrigat√≥ria")

        result = await training_service.generate_training_response(request)

        return result

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao gerar resposta de treinamento: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@router.post("/analyze-conversation")
async def analyze_conversation(conversation: List[Dict[str, Any]] = Body(...)):
    """
    Analisa uma conversa de treinamento para insights
    """
    try:
        if not conversation:
            raise HTTPException(status_code=400, detail="Conversa √© obrigat√≥ria")

        analysis = await training_service.analyze_training_conversation(conversation)

        return {
            "analysis": analysis,
            "insights": {
                "engagementLevel": "high" if analysis.get("totalMessages", 0) > 10 else "low",
                "trainingQuality": "good" if analysis.get("corrections", 0) < analysis.get("aiMessages", 0) * 0.2 else "needs_improvement",
                "conversationFlow": "natural" if analysis.get("avgMessageLength", 0) > 30 else "brief"
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao analisar conversa: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@router.post("/suggest-improvements")
async def suggest_improvements(
    conversation: List[Dict[str, Any]] = Body(...),
    teamId: str = Body(...),
    tenantId: str = Body(...)
):
    """
    Sugere melhorias baseadas na sess√£o de treinamento
    """
    try:
        analysis = await training_service.analyze_training_conversation(conversation)

        suggestions = []

        # Sugest√µes baseadas na an√°lise
        if analysis.get("corrections", 0) > analysis.get("aiMessages", 0) * 0.3:
            suggestions.append({
                "type": "training",
                "priority": "high",
                "title": "Alta taxa de corre√ß√µes",
                "description": "Considere adicionar mais contexto √† base de conhecimento ou revisar as instru√ß√µes dos agentes.",
                "action": "review_knowledge_base"
            })

        if analysis.get("avgMessageLength", 0) < 30:
            suggestions.append({
                "type": "agent_config",
                "priority": "medium",
                "title": "Respostas muito breves",
                "description": "Configure os agentes para fornecer respostas mais detalhadas e explicativas.",
                "action": "update_agent_instructions"
            })

        if len(analysis.get("topics", [])) < 2:
            suggestions.append({
                "type": "content",
                "priority": "low",
                "title": "Conversas pouco variadas",
                "description": "Teste diferentes tipos de perguntas para treinar a equipe em cen√°rios diversos.",
                "action": "diversify_training"
            })

        # Sugest√µes espec√≠ficas do dom√≠nio
        team_data = await training_service.get_team_blueprint(tenantId, teamId)
        industry = team_data.get('config', {}).get('industry', '')

        if industry == 'restaurante' and 'cardapio' not in ' '.join(analysis.get("topics", [])):
            suggestions.append({
                "type": "domain_specific",
                "priority": "medium",
                "title": "Treinamento espec√≠fico para restaurante",
                "description": "Teste perguntas sobre card√°pio, pre√ßos e pedidos para melhorar o atendimento.",
                "action": "test_menu_scenarios"
            })

        return {
            "suggestions": suggestions,
            "analysis": analysis,
            "nextSteps": [
                "Implemente as sugest√µes de alta prioridade primeiro",
                "Continue o treinamento com cen√°rios variados",
                "Monitore as m√©tricas de melhoria"
            ]
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao sugerir melhorias: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@router.get("/templates/{industry}")
async def get_training_templates(industry: str):
    """
    Retorna templates de perguntas para treinamento por setor
    """
    try:
        templates = {
            "restaurante": [
                "Qual √© o hor√°rio de funcionamento?",
                "Voc√™s fazem delivery?",
                "Qual √© o prato mais pedido?",
                "Tem op√ß√µes vegetarianas?",
                "Quanto custa o rod√≠zio?",
                "Voc√™s aceitam reservas?",
                "Qual √© a especialidade da casa?",
                "Tem estacionamento?"
            ],
            "imobiliaria": [
                "Quero alugar um apartamento de 2 quartos",
                "Qual √© o pre√ßo do metro quadrado na regi√£o?",
                "Voc√™s fazem financiamento?",
                "Quero vender minha casa",
                "Tem im√≥veis com piscina?",
                "Qual √© a documenta√ß√£o necess√°ria?",
                "Posso agendar uma visita?",
                "Voc√™s trabalham com permuta?"
            ],
            "e-commerce": [
                "Qual √© o prazo de entrega?",
                "Como fa√ßo para trocar um produto?",
                "Voc√™s aceitam cart√£o?",
                "Tem desconto para pagamento √† vista?",
                "O produto tem garantia?",
                "Como acompanho meu pedido?",
                "Fazem entrega no mesmo dia?",
                "Qual √© a pol√≠tica de devolu√ß√£o?"
            ],
            "saude": [
                "Quero agendar uma consulta",
                "Voc√™s atendem conv√™nio?",
                "Qual √© o hor√°rio de funcionamento?",
                "Tem m√©dico de plant√£o?",
                "Preciso de exames urgentes",
                "Como remarco minha consulta?",
                "Voc√™s fazem teleconsulta?",
                "Qual √© o valor da consulta particular?"
            ]
        }

        return {
            "templates": templates.get(industry, templates.get("geral", [])),
            "industry": industry,
            "total": len(templates.get(industry, []))
        }

    except Exception as e:
        print(f"Erro ao obter templates: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@router.post("/save-correction")
async def save_correction(
    teamId: str = Body(...),
    tenantId: str = Body(...),
    scenario: str = Body(...),
    badResponse: str = Body(...),
    goodResponse: str = Body(...),
    agentId: str = Body(default=None)  # ID do agente espec√≠fico (opcional)
):
    """
    Salva uma corre√ß√£o como exemplo de treinamento no agente espec√≠fico ou na equipe
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Adicionar novo exemplo
        new_example = {
            'scenario': scenario,
            'good': goodResponse,
            'bad': badResponse,
            'addedAt': datetime.now().isoformat(),
            'source': 'correction'  # Identificar que veio de corre√ß√£o
        }

        # Se um agente espec√≠fico foi informado, salvar no agente
        if agentId and agentId in team_data.get('agents', {}):
            # Inicializar estrutura de treinamento do agente se n√£o existir
            if 'agents' not in team_data:
                team_data['agents'] = {}
            if agentId not in team_data['agents']:
                team_data['agents'][agentId] = {}
            if 'training' not in team_data['agents'][agentId]:
                team_data['agents'][agentId]['training'] = {}
            if 'examples' not in team_data['agents'][agentId]['training']:
                team_data['agents'][agentId]['training']['examples'] = []

            team_data['agents'][agentId]['training']['examples'].append(new_example)

            # Atualizar agente no Firestore
            team_ref.update({
                f'agents.{agentId}.training.examples': team_data['agents'][agentId]['training']['examples']
            })

            print(f"‚úÖ Corre√ß√£o salva como exemplo de treinamento no agente '{agentId}' da equipe {teamId}")

            return {
                "success": True,
                "message": f"Corre√ß√£o salva com sucesso no agente {team_data['agents'][agentId].get('name', agentId)}",
                "totalExamples": len(team_data['agents'][agentId]['training']['examples']),
                "agentId": agentId
            }

        # Caso contr√°rio, salvar no n√≠vel da equipe (comportamento anterior)
        else:
            # Inicializar estrutura de treinamento da equipe se n√£o existir
            if 'blueprint' not in team_data:
                team_data['blueprint'] = {}
            if 'training' not in team_data['blueprint']:
                team_data['blueprint']['training'] = {}
            if 'examples' not in team_data['blueprint']['training']:
                team_data['blueprint']['training']['examples'] = []

            team_data['blueprint']['training']['examples'].append(new_example)

            # Atualizar equipe no Firestore
            team_ref.update({
                'blueprint.training.examples': team_data['blueprint']['training']['examples']
            })

            print(f"‚úÖ Corre√ß√£o salva como exemplo de treinamento geral na equipe {teamId}")

            return {
                "success": True,
                "message": "Corre√ß√£o salva com sucesso como exemplo de treinamento geral",
                "totalExamples": len(team_data['blueprint']['training']['examples'])
            }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao salvar corre√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")

@router.post("/save-metrics")
async def save_metrics(
    teamId: str = Body(...),
    tenantId: str = Body(...),
    agentId: str = Body(...),
    metrics: Dict[str, Any] = Body(...)
):
    """
    Salva m√©tricas de treinamento do agente no Firestore
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Salvar m√©tricas no agente
        metrics_data = {
            'totalMessages': metrics.get('totalMessages', 0),
            'avgResponseTime': metrics.get('avgResponseTime', 0),
            'correctionsCount': metrics.get('correctionsCount', 0),
            'avgConfidence': metrics.get('avgConfidence', 0),
            'lastUpdated': datetime.now().isoformat()
        }

        # Atualizar no Firestore
        team_ref.update({
            f'agents.{agentId}.training.metrics': metrics_data
        })

        print(f"‚úÖ M√©tricas salvas para o agente '{agentId}' da equipe {teamId}")

        return {
            "success": True,
            "message": "M√©tricas salvas com sucesso",
            "metrics": metrics_data
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao salvar m√©tricas: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


# ============================================================================
# ENDPOINTS DE VALIDA√á√ÉO PROGRAM√ÅTICA
# ============================================================================

@router.get("/validation-rules")
async def get_validation_rules(
    teamId: str,
    tenantId: str,
    agentId: str
):
    """
    Retorna todas as regras de valida√ß√£o configuradas para um agente.

    Args:
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente

    Returns:
        {
            "enabled": true,
            "rules": [
                {
                    "id": "rule_123",
                    "name": "Validar agendamentos",
                    "description": "...",
                    "trigger_keywords": [...],
                    "entity_extraction": {...},
                    "strictness": "high",
                    "auto_correct": false,
                    "enabled": true,
                    "createdAt": "...",
                    "updatedAt": "..."
                }
            ]
        }
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Obter configura√ß√£o de valida√ß√£o do agente
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        agent = agents[agentId]
        validation_config = agent.get('validation_config', {
            "enabled": False,
            "rules": []
        })

        print(f"‚úÖ Regras de valida√ß√£o obtidas para agente '{agentId}': {len(validation_config.get('rules', []))} regras")

        return validation_config

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao obter regras de valida√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


@router.post("/validation-rules")
async def create_validation_rule(
    teamId: str = Body(...),
    tenantId: str = Body(...),
    agentId: str = Body(...),
    rule: Dict[str, Any] = Body(...)
):
    """
    Cria uma nova regra de valida√ß√£o para um agente.

    Args:
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente
        rule: Configura√ß√£o da regra (sem ID, ser√° auto-gerado)
            {
                "name": "Validar agendamentos",
                "description": "...",
                "trigger_keywords": ["agendar", "marcar"],
                "entity_extraction": {
                    "service_type": {
                        "method": "regex",
                        "pattern": "consulta\\s+(?:de\\s+)?(\\w+)",
                        "description": "Tipo de consulta"
                    }
                },
                "strictness": "high",
                "auto_correct": false,
                "enabled": true
            }

    Returns:
        {
            "success": true,
            "ruleId": "rule_abc123",
            "message": "Regra criada com sucesso"
        }
    """
    try:
        from firebase_admin import firestore
        import uuid

        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Verificar se agente existe
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        # Gerar ID √∫nico para a regra
        rule_id = f"rule_{uuid.uuid4().hex[:8]}"

        # Adicionar metadados √† regra
        new_rule = {
            "id": rule_id,
            **rule,
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }

        # Obter ou inicializar validation_config
        agent_path = f'agents.{agentId}.validation_config'
        validation_config = agents[agentId].get('validation_config', {
            "enabled": False,
            "rules": []
        })

        # Adicionar nova regra
        validation_config['rules'].append(new_rule)

        # Atualizar no Firestore
        team_ref.update({
            f'{agent_path}.rules': validation_config['rules']
        })

        print(f"‚úÖ Regra de valida√ß√£o '{rule.get('name')}' (ID: {rule_id}) criada para agente '{agentId}'")

        return {
            "success": True,
            "ruleId": rule_id,
            "message": f"Regra '{rule.get('name')}' criada com sucesso",
            "rule": new_rule
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao criar regra de valida√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


@router.put("/validation-rules/toggle")
async def toggle_validation_system(request: ToggleValidationRequest):
    """
    Ativa ou desativa todo o sistema de valida√ß√£o para um agente.

    Args:
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente
        enabled: True para ativar, False para desativar

    Returns:
        {
            "success": true,
            "enabled": true,
            "message": "Sistema de valida√ß√£o ativado"
        }
    """
    # Extrair campos do request Pydantic
    teamId = request.teamId
    tenantId = request.tenantId
    agentId = request.agentId
    enabled = request.enabled

    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Verificar se agente existe
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        # Atualizar estado do sistema de valida√ß√£o
        agent_path = f'agents.{agentId}.validation_config'
        team_ref.update({
            f'{agent_path}.enabled': enabled
        })

        status_msg = "ativado" if enabled else "desativado"
        print(f"‚úÖ Sistema de valida√ß√£o {status_msg} para agente '{agentId}'")

        return {
            "success": True,
            "enabled": enabled,
            "message": f"Sistema de valida√ß√£o {status_msg} com sucesso"
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao alternar sistema de valida√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


@router.put("/validation-rules/{ruleId}")
async def update_validation_rule(
    ruleId: str,
    teamId: str = Body(...),
    tenantId: str = Body(...),
    agentId: str = Body(...),
    updates: Dict[str, Any] = Body(...)
):
    """
    Atualiza uma regra de valida√ß√£o existente.

    Args:
        ruleId: ID da regra a ser atualizada
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente
        updates: Campos a serem atualizados

    Returns:
        {
            "success": true,
            "message": "Regra atualizada com sucesso"
        }
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Verificar se agente existe
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        # Obter validation_config
        validation_config = agents[agentId].get('validation_config', {
            "enabled": False,
            "rules": []
        })

        # Encontrar regra a ser atualizada
        rules = validation_config.get('rules', [])
        rule_index = None

        for i, r in enumerate(rules):
            if r.get('id') == ruleId:
                rule_index = i
                break

        if rule_index is None:
            raise HTTPException(status_code=404, detail=f"Regra '{ruleId}' n√£o encontrada")

        # Atualizar campos
        updated_rule = {**rules[rule_index], **updates}
        updated_rule['updatedAt'] = datetime.now().isoformat()

        # Substituir regra antiga pela atualizada
        rules[rule_index] = updated_rule

        # Atualizar no Firestore
        agent_path = f'agents.{agentId}.validation_config'
        team_ref.update({
            f'{agent_path}.rules': rules
        })

        print(f"‚úÖ Regra de valida√ß√£o '{ruleId}' atualizada para agente '{agentId}'")

        return {
            "success": True,
            "message": f"Regra '{updated_rule.get('name')}' atualizada com sucesso",
            "rule": updated_rule
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao atualizar regra de valida√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


@router.delete("/validation-rules/{ruleId}")
async def delete_validation_rule(
    ruleId: str,
    teamId: str = Body(...),
    tenantId: str = Body(...),
    agentId: str = Body(...)
):
    """
    Remove uma regra de valida√ß√£o.

    Args:
        ruleId: ID da regra a ser removida
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente

    Returns:
        {
            "success": true,
            "message": "Regra removida com sucesso"
        }
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Verificar se agente existe
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        # Obter validation_config
        validation_config = agents[agentId].get('validation_config', {
            "enabled": False,
            "rules": []
        })

        # Filtrar regras (remover a que tem o ID especificado)
        rules = validation_config.get('rules', [])
        original_count = len(rules)
        rules = [r for r in rules if r.get('id') != ruleId]

        if len(rules) == original_count:
            raise HTTPException(status_code=404, detail=f"Regra '{ruleId}' n√£o encontrada")

        # Atualizar no Firestore
        agent_path = f'agents.{agentId}.validation_config'
        team_ref.update({
            f'{agent_path}.rules': rules
        })

        print(f"‚úÖ Regra de valida√ß√£o '{ruleId}' removida do agente '{agentId}'")

        return {
            "success": True,
            "message": f"Regra removida com sucesso",
            "remainingRules": len(rules)
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao remover regra de valida√ß√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")


@router.post("/save-suggestion")
async def save_suggestion(
    teamId: str = Body(...),
    tenantId: str = Body(...),
    agentId: str = Body(...),
    suggestion: Dict[str, Any] = Body(...)
):
    """
    Salva uma SUGEST√ÉO de comportamento (regra de IA) para o agente.

    Diferente de save-correction (exemplos de few-shot), suggestions s√£o regras
    comportamentais que influenciam QUANDO e COMO o agente deve agir.

    Args:
        teamId: ID da equipe/crew
        tenantId: ID do tenant (valida√ß√£o)
        agentId: ID do agente
        suggestion: Configura√ß√£o da sugest√£o
            {
                "trigger": "Cliente pede agendamento sem fornecer data",
                "behavior": "SEMPRE pergunte a data/hora desejada ANTES de consultar a base de conhecimento",
                "category": "validation",
                "priority": "critical"  # critical | high | medium | low
            }

    Returns:
        {
            "success": true,
            "message": "Sugest√£o salva com sucesso",
            "totalSuggestions": 5
        }
    """
    try:
        from firebase_admin import firestore
        db = firestore.client()

        # Buscar equipe
        team_ref = db.collection('crews').document(teamId)
        team_doc = team_ref.get()

        if not team_doc.exists:
            raise HTTPException(status_code=404, detail="Equipe n√£o encontrada")

        team_data = team_doc.to_dict()

        # Verificar se pertence ao tenant
        if team_data.get('tenantId') != tenantId:
            raise HTTPException(status_code=403, detail="Acesso negado")

        # Verificar se agente existe
        agents = team_data.get('agents', {})
        if agentId not in agents:
            raise HTTPException(status_code=404, detail=f"Agente '{agentId}' n√£o encontrado")

        # Adicionar metadados √† sugest√£o
        new_suggestion = {
            **suggestion,
            "addedAt": datetime.now().isoformat(),
            "source": "manual"  # manual | auto_learned
        }

        # Obter ou inicializar training.suggestions
        agent = agents[agentId]
        if 'training' not in agent:
            agent['training'] = {}
        if 'suggestions' not in agent['training']:
            agent['training']['suggestions'] = []

        agent['training']['suggestions'].append(new_suggestion)

        # Atualizar no Firestore
        agent_path = f'agents.{agentId}.training.suggestions'
        team_ref.update({
            agent_path: agent['training']['suggestions']
        })

        print(f"‚úÖ Sugest√£o de comportamento salva para agente '{agentId}':")
        print(f"   Trigger: {suggestion.get('trigger')}")
        print(f"   Priority: {suggestion.get('priority')}")

        return {
            "success": True,
            "message": "Sugest√£o salva com sucesso",
            "totalSuggestions": len(agent['training']['suggestions']),
            "suggestion": new_suggestion
        }

    except HTTPException:
        raise
    except Exception as e:
        print(f"Erro ao salvar sugest√£o: {e}")
        raise HTTPException(status_code=500, detail=f"Erro interno: {str(e)}")